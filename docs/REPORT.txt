===============================================
 Advanced Operating Systems and Virtualization 
            Final Project Report
===============================================

 - Student Full Name: Andrea Fioraldi
 - Student ID: 1692419
 - Academic Year: 2018/2019

1) Introduction
===============

The File Access with Session (FAS) is a method to handle files in the operating
system in which processes does not have to compete for the I/O on a file.

In standard POSIX files, each I/O session on a resource is concurrent with
others and the involved processe has to ensure the consistency using a
synchronization meachanism and/or permissions.

Using FAS, each instance has a temporary view of the file that can be modified
only by the instance itself.
The changes are then flushed to the resource when the session is closed in a
way similar in spirit to the commit of a transaction in a database system.

We implemented a Linux Kernel Module (LKM) that enable the userspace to use
FAS on files inside an user-specified directory and its sub-directories. 

2) User Space
=============

2.1) Library
------------

If you rely on some userspace library to wrap access to kernel-level facilities,
this is the place to describe its interface to applications and it internal
organization.

int fas_init()

This routine has to be called in the main thread of the application before any
calls to fas_open. It opens the /dev/fas device and the return value is its
file descriptor.

int fas_open(char* pathname, int flags, mode_t mode)

This routine is the entry point to the creation of session files.
Use it just the POSIX open, the differences are:
 - O_PATH is not supported, use the POSIX open(2) for it
 - O_TMPFILE is not supported, a temporary session file has no sense

pathname must be a subpath of the initial path (see subsection 2.2).

fas_open returns the opened file descriptor or a POSIX error code in case of
error. On such file descriptor, standard files syscalls like write(2), read(2),
lseek(2), close(2) can be invoked.

A note on close(2): Closing a session file may be a not immediate operation.
The content of the session file is flushed to the original file and this
can take time. close(2) raises SIGPIPE (and so returns -EPIPE) if the original
file cannot be opened anymore. This is not done simply when the original file
was unlinked brefore the close, but is connected to the flags passed to
fas_open.

Consider this example of code:

  fd = fas_open("/var/log/mylog", O_RDWR | O_NOFOLLOW, 0);
  // Do not allow symlinks for whatever reason
  write(fd, user_controlled_data, strlen(user_controlled_data));
  do_something();
  close(fd);

Now imagine an attacker that wants to replace /var/log/mylog with a symlink to
break the program assumptions exploiting the TOCTOU between fas_open and close:
  
  unlink("/var/log/mylog");
  symlink("bad_guy", "/var/log/mylog");

A close that does not check again the flags of the original file will write the
content of user_controlled_data into "bad_guy". Actually, flags are checked
and in this example SIGPIPE is raised and the commit operation blocked.

2.2) SysFS
----------

An user can get and set the FAS initial path (i.e. only the failes in subpaths of the
initial path can be opened with fas_open) reading and writing to
/sys/kernel/fas/initial_path.

Reading /sys/kernel/fas/sessions_num an user can get the number of opened
session files in the entire OS.

Reading /sys/kernel/fas/sessions_each_file an user can know how many sessions
are opened for each file that has at least one opened session.
Each file is a line in the output, each line is in the format
<filename> <number of sessions>

Reading /sys/kernel/fas/processes an user can know which processes are using
session files. Each line refers to a process and has the format
<process image filename> <pid>

3) Kernel-Level Data Structures
===============================

The FAS kernel module havily makes use of a Radix Tree. Each key is a
struct file instance of a session. The tree maps the session files to a
struct fas_filp_info instance, a structure defines as follows:

struct fas_filp_info {

  struct file_operations *orig_f_op;
  char                    pathname[PATH_MAX];
  int                     flags;
  unsigned char           is_w;

};

orig_f_op is the pointer to the original file operations of the session file.
Currently, the session files have a patched file_operations structure (see
section 4).
pathname is the pathname of the original file. flags are the flags passed
to fas_open and is_w tells if the close operation has to commit the changes
to the original file.

4) Kernel-Level Subsystem Implementation
========================================

Describe here the implementation of your subsystem. You can insert code
snippets, add as many subsections as you want. Try to be as clear as possible.

5) Testcase and Benchmark
=========================

Describe here how you have tested your implementation. If you have carried out
performance tests, this is the place to describe them and give the results.

